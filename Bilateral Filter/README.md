# Лабораторная работа №2: Bilateral filter (билатеральный фильтр)
***

## Постановка задачи:

Реализовать алгоритм бидатерального фильтра.
 
Язык: __C++__

Технологии: __CUDA__, __OPENCV__

Входные данные: изображение в оттенках серого, стандартное отклонение *σ*.

Выходные данные: время вычисления на CPU, GPU и выходное изображение.

## Описание работы программы на CUDA:

[Теория](https://github.com/PavelYakimov/HPC-SamaraUniversity-Fall-2021/blob/main/bilateral.pdf)

Как было отмечено, распараллеливание заключается в том, чтобы каждая нить высчитывала новую яркость своего пикселя.

Для этого сначала высчитывались координаты нити и соответствующего пикселя:

```
int x = blockIdx.x * BLOCK_SIZE + threadIdx.x;
int y = blockIdx.y * BLOCK_SIZE + threadIdx.y;
```

Проверялось, данный пиксель находится внутри изображения. Если да, то он брался в качестве центрального пикселя. Для этого использовалась двумерная текстура, объявленная с помощью __tex2D__:

```
unsigned char center = tex2D(texture_ref, x, y);
```

Для этого пикселя рассматривались соседи, находящиеся в определенном радиусе __filter_radius__. Относительно них вычислялись коэффициенты Гауссова размытия и новую яркость:

```
for (int i = -filter_radius; i <= filter_radius; i++) {
	 for (int j = -filter_radius; j <= filter_radius; j++) {
  
   unsigned char curr_pixel = tex2D(texture_ref, x + j, y + i);
   
   double factor = gpu_gauss[i + filter_radius] 
                    * gpu_gauss[j + filter_radius] 
                    * kernel_euclid_distance(center - curr_pixel, sigma);
                    
    h += factor * curr_pixel;
    k += factor;
  }
}

```

В конце, результирующей яркостью для пикселя будет нормализванная яркость относительно соседей внутри радиуса:

```
output[y * width + x] = h / k;
```

## Пример работы программы:

Пример входного изображения:

![Входное изображение](https://github.com/DimaScientist/HPC/blob/main/Bilateral%20Filter/images/eiffel_640_400.jpg)

Пример работы программы при *σ = 100*:

![Выходное изображение](https://github.com/DimaScientist/HPC/blob/main/Bilateral%20Filter/images/result.jpg)


## Результаты экспериментов:

Обозначения:

* n - размер изображения в пикселях;

* t_gpu - время работы программы на CUDA;

* t_cpu - время работы программы на CPU;

* S = t_cpu / t_gpu - ускорение.

| параметр \ n | 400 x 640    | 720 x 1280   | 1600 x 2560   | 3744 x 5616    |
| ------------ | ------------ | ------------ | ------------- | -------------- | 
| t_cpu, мс    |  46          | 160          | 774           | 3569           | 
| t_gpu, мс    | 5803         | 20692        | 93541         | 461286         |
| S            | 126          | 129          | 121           | 129            |

График зависимости времени работы программы на __CPU__ от размера изображения:

![График зависимости времени работы программы на CPU от размера изображения](https://github.com/DimaScientist/HPC/blob/main/Bilateral%20Filter/images/cpu.png)

График зависимости времени работы программы на __GPU__ от размера изображения:

![График зависимости времени работы программы на GPU от размера изображения](https://github.com/DimaScientist/HPC/blob/main/Bilateral%20Filter/images/gpu.png)

График зависимости __ускорения__ от размера изображения:

![График зависимости ускорения от размера изображения](https://github.com/DimaScientist/HPC/blob/main/Bilateral%20Filter/images/boost.png)

## Выводы:

1. Программа с использованием CUDA (GPU) работает бысрее, чем на CPU;
2. С увеличением размера изображения увеличивается и время работы программы. По графику ускорения видно, что время работы программы на CPU растёт быстрее, чем на GPU.
